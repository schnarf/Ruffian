def factorial ( int n ) -> int {
	if( n == 0 ) { return 1; }
	return n * factorial(n - 1);
}

def fibonacci( int n ) -> int {
	if( n < 3 ) { return 1; }
	return fibonacci(n-1) + fibonacci(n-2);
}

def decl_test(int n) -> int {
	int ret;
	if( n < 3 ) {
		int x= factorial(n);
		ret= x;
	} else {
		int x= fibonacci(n);
		ret= x;
	}

	return ret;
}

def bool_test(int n) -> int {
	bool bValue= true;
	bValue= n < 3;
	if( bValue ) {
		return n;
	}
	return 3;
}

def opt_test(int x) -> int {
	return (1+2+x) * (x+(1+2));
}

def stefs_function(int x) -> int {
	return x*x*x;
}

def prototype2(int x) -> int;

def prototype1(int x) -> int {
	return prototype2(x);
}

def prototype2(int x) -> int {
	return 1 + x;
}

def prototype2(int x) -> int;

def operator_precedence(int x, int y) -> int {
	int b= y / x + 3 * (y - x);
	return b;
}

def printInt(int n);
def printFloat(float f);
def printDouble(double f);
def printNewline();
def rand() -> int;

def printIntArray( int[] array, int n ) {
	for( int i=0; i<n; ++i ) {
		printInt( array[i] );
	}
}

def insertion_sort( int[] a, int n ) {
	for( int i=0; i<n; ++i ) {
		int min= i;
		for( int j=i+1; j<n; ++j ) {
			if( a[j] < a[min] ) { min= j; }
		}
		int temp= a[i];
		a[i]= a[min];
		a[min]= temp;
	}
}

// iLeft is the index of the leftmost array element
// iRight is the index of the rightmost array element, inclusive
// Arranges the elements between iLeft and iRight so that the ones
// less than the pivot come before it, and the ones greater than
// it come after, and moves the pivot into its final position, returning that position
def partition( int[] a, int iLeft, int iRight, int iPivot ) -> int {
	int iPivotValue= a[iPivot];
	int temp;

	// Move pivot to end
	temp= a[iPivot];
	a[iPivot]= a[iRight];
	a[iRight]= temp;

	int iStore= iLeft;
	for( int i=iLeft; i<iRight; ++i ) {
		if( a[i] < iPivotValue ) {
			temp= a[i];
			a[i]= a[iStore];
			a[iStore]= temp;
			iStore= iStore + 1;
		}
	}

	// Move pivot to its final place
	temp= a[iStore];
	a[iStore]= a[iRight];
	a[iRight]= temp;

	return iStore;
}

def quicksort_helper( int[] a, int iLeft, int iRight ) {
	// If the list is empty or one item, it's sorted
	if( iLeft >= iRight ) { return; }

	// Choose a pivot
	int iPivot= (iLeft + iRight) / 2;

	// Partition the array
	int iNewPivot= partition( a, iLeft, iRight, iPivot );

	// Recursively sort the left and right parts
	quicksort_helper( a, iLeft, iNewPivot-1 );
	quicksort_helper( a, iNewPivot+1, iRight );
}

def quicksort( int[] a, int n ) {
	quicksort_helper( a, 0, n-1 );
}

def main(int n) -> int {
	int[n] array;

	for( int i=0; i<n; ++i ) {
		array[i]= rand();
	}

	printIntArray( array, n );
	
	quicksort( array, n );

	printNewline();
	printIntArray( array, n );

	return 0;
}